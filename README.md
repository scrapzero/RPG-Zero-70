# SukenlibObjective
　70期Photonが再構成した、オブジェクト指向型の新しい数研ライブラリをさらに書き直したライブラリです。
　VS２０１０～　で使うことができます。
　最大の特徴は、シーンひとつごとにクラスを作るようになったのと、
　豊富なシーン切り替え効果、ルール画像を用いた多彩なトランシジョン。
/*そして、すべてのオブジェクトをシーンごとに一元管理し、描画や当たり判定などを
　まとめてすることができるようになった点です。この機能は自由に追加できます。（未実装）*/
　
　リファレンスのURLです。
　＜ver1.0＞
　https://www.dropbox.com/s/kou4aqsl0fm5fis/SukenLibObjective%20%20ver%201.0%20%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9.zip?dl=0
　ダウンロードして、解凍して、「リファレンスを読む」を実行してください
　
# シーンクラスの書き方
　こんな感じです。
　class MyScene:public CScene{
　public:
　　MyScene()		//必要に応じてコンストラクタを作る
　private:
　　//シーンで使う変数はここで宣言する

　　void Start();	//初期化
　　void Loop();	//処理
　　void Draw();	//描画
　　void End();		//後片付け
　};

　ここに書いた四つの関数は、Gameクラス、もしくはSceneクラスから呼ばれます。
　四つの関数は必ずすべて書く必要はありません。
　クラス内で使う関数は、必要に応じて作って構いません

# Gameクラスについて
　Gameとはゲーム内のすべてのシーンの親で、これ自身もCSceneの継承クラスです。
　Game.～と書くことで、シーン切り替えができますがGameを用いたシーン切り替えには二種類あります

　　Game.Init()
　　　Main.cpp内の、suken::Awake()でのみ、使うことを許される関数です。
　　　この関数を使えば、最初のロード画面からのシーン切り替え効果が使えます。
　　　Awake()以外で使ったり、二回使ったり、Awake()ないでFlipScene()を使えば、
　　　呪い殺されますので、注意してください。
　　
　　Game.FlipScene()
　　　どこでも使える関数です。シーン切り替え効果を使えます
　　　Awake()以外なら、使っても呪い殺されることはないので、安心してください

　ちなみに、FlipScene(new CGame())や、Init(new CGame())と書いても、呪い殺されます。

# 真面目にFlipScene()について解説する
　Init()も、FlipScene()も、引数は同じです。
　FlipScene(new シーンクラス（）,～)みたいな感じです。

　　・CScene* scene
　　　「new Sceneの継承クラス() 」と書けばいいです。必要に応じてコンストラクタの引数を入れてください

　　・const char*　ruleGraph
　　　「ルール画像」とネットで検索しましょう。
　　　それをダウンロードして、その画像のある場所を書いてやれば、それを使えます　「"rulrGraph.png"」のようにすればOKです。

　　・const char*　ruleGraph2
　　　ルール画像を二つ使う場合に入れます。
　　　上と同じです。効果は見たらわかります。

　　・Flip::Type　flipType
　　　「Flip.～」を入れればいいです。効果は読んで字のごとくです。
　　　僕が見よう見まねで作ったシーン切り替えが使えます。

　　・const char speed
　　　速度です。0～255の範囲で入れてください。255だとシーン切り替え効果はほとんどわかりません。

　　・const char gradate
　　　「ルール画像」を使うときに入れます。１か６４か１２８か２５５を設定できます。
　　　大きくするほどぼやけます。

# 子シーン切り替えについて
　実はCSceneの継承クラスはすべて、子シーンを持つことができます。
　それを扱う関数について、軽く解説していきます。引数は、「真面目にFlipScene()について解説する」の
　項目を見てください。

　　・CSceneのコンストラクタ
　　　シーンが切り替わって直後に子シーンを持たせたいときは、CSceneのコンストラクタを使います。
　　　MyScene(～)：　CScene(～)｛　～
　　　のように使えます。よくわからなかったら、「基底クラス　コンストラクタ　引数」で検索してみてください。

　　・FlipScene
　　　子シーンの追加、切り替えに使います。Game.FlipScene　ではなく、　クラス内で　FlipScene（）と書けば、そのクラスに子シーンを持たせることができます。

　　・RemoveScene
　　　子シーンの削除ができます。

# 子シーンの作法
　子シーンの書き方については、いろいろな利便性を考えて、次のように統一してほしいです

　　class Parent:public CScene{
　　　～
　　　class Child:public CScene{
　　　public:
　　　　Parent＆　parent;
　　　　～
　　　　Child(Parent& parent,~);
　　　　～
　　　};
　　　～
　　};

　　Parent::Child::Child(Parent& parent,～):parent(parent){ ～

　　解説すると、クラス内にクラスの定義を書くと、インナークラスといい、上の例だと
　　Parent::Child
　　のように書けます、これで、どのシーンの子シーンなのかがわかりやすいので採用しました。ほかにも利点はありますが、説明は省きます。
　　親シーンの変数は、上の例だと、子シーンないで、
　　parent.～
　　のように書けます。この場合、ChildにFlipSceneするときに、親シーン内で
　　FlipScene(new Child(*this),～)
　　と書く必要があります。
　　こうすると、子シーンが自分を消すときに、
　　parent.RemoveScene(～)
　　のように書けるので、便利です。

# シーンクラスで使えるその他の関数
　上で書いた関数以外に、シーンクラスの継承クラスで使える関数があります。

　　・SetBlendMode
　　　シーンごとにBlendModeを設定できます。詳細はDxLibのSetDrawBlendModeのリファレンスを見ればわかるとおもいます。

　　・SetBright
　　　シーンごとに描画輝度を(ry

# System.でできること
　System.～で様々な関数を利用できます。
　読んで字の如くな関数ばかりなので、説明は省きますが、
　System.～　で出てくる関数は自由に使っていいものなので、使ってみてください。

# 入力関連情報の取得について
　Event.～　が使えなくなった代わりにInput.～で入力情報を使うことができます。
　キーやマウスボタンの判定関数の名前がややこしいので、軽く説明します。

　　・～Down
　　　押されている間trueを返します

　　・～Enter
　　　押された瞬間にtrueを返します

　　・～Exit
　　　離された瞬間にtrueを返します

　ほかの関数については、「リファレンスを見る」で確認してください。

# その他便利な構造体
　Utilityには便利な様々な構造体が入っています。その一部を紹介します。

　　・Graph
　　　画像を扱う構造体です。
　　　Graph graph;　で宣言して
　　　graph = "画像ファイル.png";　でロードして、
　　　graph(x,y);　で描画できます。いわゆる関数オブジェクトというやつです

　　・LoadDivGraph()
　　　関数ですが、紹介します。DxLibにもともと入っていたものとは違って、「GraphVec」で返します。
　　　GraphVecは、「std::vector<Graph>」の別名です。
　　　これを用いて画像を分割読み込みします。
　　　引数は、　画像名、分割後の横幅、分割後の高さ　です。

　　・Anim
　　　アニメーションの構造体です。
　　　Anim　anim;
　　　anim = LoadDivGraph(～);
　　　anim(x,y);
　　　と書くだけで、画像をアニメーションさせることができます。
　
#### オブジェクトはすべてシーンに管理させよう!!!

 CObjectを継承したクラスは、AddObjectして、シーンに管理させ、関数を実行させることができますが、
　これまでは、すべてのオブジェクトを一緒くたにしていたので、いろいろとややこしいことになっていました。
　しかし、これからは違います。CObjectを継承したクラスごとに、マネージャーを作ることができるようになりました!!!
　作り方は簡単で、マネージャーを作りたいシーンのStart()で、UseManager<オブジェクト名>()とするだけで、
　デフォルトのオブジェクトマネージャーを使うことができます。
　テンプレートの特殊化を理解していれば、クラスごとに独自のマネージャーを作ることができます。
　マネージャーにオブジェクトをついかするには、AddObjectToManager<オブジェクト名>(new ～～)を使います
　マネージャーのポインタは、GetManager<オブジェクト名>()で入手でき、作成していない場合はnullptrが返されます
　あるマネージャーに対して処理を行うには、Algorithm構造体を使います。シーンのポインタをコンストラクタに入れ、
　Algorithm　alg(this);
　alg.関数名<オブジェクト名>(引数)
　で操作ができます。
　ヘッダーファイル、algorithmに存在するアルゴリズムや、衝突判定のための二つのマネージャーを使うアルゴリズムなどを随時追加していきます。

　
#### オブジェクトマネージャーについて

　CManagerBaseを継承したテンプレートクラス、CManager<>のことです。
　基本的な動作は大体作ってますが、特殊化を利用すると関数などを追加することができます。
　